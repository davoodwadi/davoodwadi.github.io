{
  "hash": "62b1aee5e3746916b7073265244cbc45",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"\"\nformat:\n  html:\n    code-fold: false\njupyter: python3\nexecute: \n  cache: true\neval: false\n---\n\n\n\n\n\n# Policy Iteration Algorithm\n\nIn reinforcement learning, the **policy iteration algorithm** is used to find the optimal policy for an agent to maximize its expected return in a Markov Decision Process (MDP). The algorithm consists of two main steps: policy evaluation and policy improvement. \n\n1. **Policy Evaluation**: In this step, we evaluate the given policy by calculating the state-value function for each state. The state-value function, denoted as V(s), represents the expected return starting from state s and following the given policy. The Bellman equation for V(s) is given by:\n\n$V(s) = \\sum_{a} \\pi(a|s) \\sum_{s',r} p(s', r|s, a) [r + \\gamma V(s')]$\n\nwhere:\n\n- $\\pi(a|s)$ is the probability of taking action a in state s according to the policy $\\pi$.\n- $p(s',r|s,a)$ is the probability of transitioning to state s' and receiving reward r, given that the agent took action a in state s.\n- $\\gamma$ is the discount factor, which determines the importance of future rewards compared to immediate rewards.\n\nThe policy evaluation step involves iteratively updating the state-value function until it converges to its true value under the given policy. \n\n2. **Policy Improvement**: Once the state-value function is updated, we can improve the policy by selecting the action that maximizes the expected return in each state. This can be done by using the *greedy policy improvement* rule:\n\n\n$\\pi'(s) = \\arg\\max_{a} \\sum_{s', r} p(s', r|s, a) [r + \\gamma V(s')]$\n\n\nwhere $\\pi'(s)$ is the new policy, and $V(s')$ is the updated state-value function.\n\nThe policy improvement step involves updating the policy based on the updated state-value function from the previous step.\n\nThis process of policy evaluation and policy improvement is repeated iteratively until the policy converges to the optimal policy.\n\nNow let's see an example of how to implement the policy iteration algorithm in Python:\n\n::: {#399e521b .cell execution_count=2}\n``` {.python .cell-code}\n# Step 1: Policy Evaluation\ndef policy_evaluation(policy, states, actions, rewards, transitions, discount_factor, theta):\n    # Initialize the state-value function with zeros\n    V = {s: 0 for s in states}\n\n    while True:\n        delta = 0\n        \n        # Iterate over all states\n        for s in states:\n            v = V[s]\n            new_v = 0\n            \n            # Iterate over all possible actions\n            for a in actions:\n                # Compute the expected return for each action\n                next_states = transitions[s][a]\n                expected_return = sum(prob * (reward + discount_factor * V[next_state]) for next_state, reward, prob in next_states)\n\n                # Compute the new state-value function\n                new_v += policy[s][a] * expected_return\n\n            # Update the state-value function for the current state\n            V[s] = new_v\n\n            # Calculate the maximum difference between the old and new state-value functions\n            delta = max(delta, abs(v - V[s]))\n        \n        # If the maximum difference is less than a threshold, we assume convergence\n        if delta < theta:\n            break\n    \n    return V\n\n# Step 2: Policy Improvement\ndef policy_improvement(states, actions, rewards, transitions, discount_factor, V):\n    # Initialize the new policy with zeros\n    new_policy = {s: {a: 0 for a in actions} for s in states}\n    \n    for s in states:\n        action_values = []\n        \n        # Iterate over all possible actions\n        for a in actions:\n            # Compute the expected return for each action\n            next_states = transitions[s][a]\n            expected_return = sum(prob * (reward + discount_factor * V[next_state]) for next_state, reward, prob in next_states)\n            \n            # Add the expected return to the list of action values\n            action_values.append(expected_return)\n        \n        # Assign the action with the maximum expected return as the new policy for the current state\n        idx = np.argmax(action_values)\n        new_policy[s][actions[idx]] = 1\n    \n    return new_policy\n\n# Step 3: Policy Iteration\ndef policy_iteration(states, actions, rewards, transitions, discount_factor, theta):\n    # Initialize a random policy\n    policy = {s: {a: 1 / len(actions) for a in actions} for s in states}\n\n    while True:\n        # Policy Evaluation\n        V = policy_evaluation(policy, states, actions, rewards, transitions, discount_factor, theta)\n        \n        # Policy Improvement\n        new_policy = policy_improvement(states, actions, rewards, transitions, discount_factor, V)\n        \n        # If the new policy is the same as the old policy, we have converged to the optimal policy\n        if policy == new_policy:\n            break\n        \n        policy = new_policy\n    \n    return policy\n```\n:::\n\n\nIn the code above, we define three functions to implement the policy iteration algorithm:\n\n1. `policy_evaluation`: This function performs policy evaluation by iteratively updating the state-value function until it converges. It takes as input the policy, state and action spaces, rewards, transition probabilities, discount factor, and a convergence threshold.\n\n2. `policy_improvement`: This function improves the policy by selecting the action that maximizes the expected return in each state. It takes as input the state and action spaces, rewards, transition probabilities, discount factor, and the updated state-value function.\n\n3. `policy_iteration`: This function combines the policy evaluation and policy improvement steps to find the optimal policy. It iteratively updates the policy until it converges to the optimal policy.\n\nTo apply the policy iteration algorithm to a specific problem, you need to provide the state and action spaces, rewards, transition probabilities, discount factor, and convergence threshold.\n\nNow you can use the `policy_iteration` function to find the optimal policy for a given MDP.\n\n",
    "supporting": [
      "policy iteration_files"
    ],
    "filters": [],
    "includes": {}
  }
}