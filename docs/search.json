[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Davood Wadi",
    "section": "",
    "text": "I’m a researcher and educator with a focus on Digital Marketing and the application of Artificial Intelligence in Marketing.\nI currently teach the following courses:"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "courses.html",
    "href": "courses.html",
    "title": "MATH60629A - Machine Learning I (Fall 2023)",
    "section": "",
    "text": "Code Tutorials | Contact Information | Bibliographic Sources | Class Information | Evaluations | Session Materials\n\n\n\nWeek 1\n\nPython basics\n\nWeek 2\n\nModel capacity\nOverfitting\n\n\n\n\n\n\n\n\n\n\n\n\nDavood Wadi\n\nPart-time Faculty Lecturer\ndavood.wadi@hec.ca\nFor office hours:\n\nBook meeting\n\n\nValérie Boucher\n\nAssistant to Academic Activities\nvalerie.boucher@hec.ca\n514-340-5670\nOffice: 4.632\nAvailability:\n\nMonday to Friday\n8:30 a.m. to 12 p.m. and 1 to 4:00 p.m.\n\n\nAntonietta Florio\n\nAssistant to Academic Activities\nantonietta.florio@hec.ca\n514-340-6473\nOffice: 4.632\nAvailability:\n\nFrom Monday to Friday\nFrom 8 am to 12 pm and from 1 pm to 4:30 pm\n\n\nJennifer Caron\n\nExecutive Assistant\njennifer.caron@hec.ca\n514-340-6473\nOffice: 4.632\nAvailability:\n\nFrom Monday to Friday\nFrom 8 am to 12 pm and from 1 pm to 4:30 pm\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Elements of Statistical Learning: Data Mining, Inference, and Prediction\n\nAvailable online\n\nGoodfellow, Ian . Deep learning , MIT Press ISBN: 9780262035613\n\nAvailable online\n\nRichard S. Sutton, Andrew G. Barto. A Bradford Book (2017 (in progress)). Reinforcement Learning: An Introduction Hardcover, 2nd edition ed., The MIT Press\n\nAvailable online\n\nMurphy, Kevin (2012). Machine Learning: A Probabilistic Perspective, MIT Press ISBN: 9780262018029\n\nAvailable at the library\n\nRicci, Francesco. Recommender systems handbook, Springer ISBN: 148997637X\n\nAvailable at the library\n\nParsian, Mahmoud (2015). Data algorithms: recipes for scaling up with Hadoop and Spark, O’Reilly Media ISBN: 9781491906156\n\nAvailable at the library\n\nMcKinney, Wes. Python for data analysis: data wrangling with Pandas, NumPy, and IPython, O’Reilly Media\n\nAvailable at the library\n\nBishop, Christopher (2006). Pattern Recognition and Machine Learning, Springer-Verlag New York ISBN: 9780387310732\n\nAvailable at the library\n\nLeskovec, Jurij. Mining of massive datasets, Cambridge University Press\n\nAvailable at the library\n\nGrus, Joel. Data science from scratch, O’Reilly Media\n\nAvailable at the library\n\nSandy Ryza, Uri Laserson, Sean Owen, Josh Wills (2017). Advanced analytics with Spark: patterns from learning from data at scale, 2nd edition ed., O’Reilly Media\n\nAvailable at the library\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLocation\n\nBuilding C-Ste-Cath, Room Groupe Cholette\n\nTime\n\nTuesdays, 3:30 PM - 6:30 PM EDT"
  },
  {
    "objectID": "index.html#about-this-blog",
    "href": "index.html#about-this-blog",
    "title": "Courses",
    "section": "About this blog",
    "text": "About this blog\nI currently teach the following courses:"
  },
  {
    "objectID": "index.html#courses",
    "href": "index.html#courses",
    "title": "Davood Wadi",
    "section": "Courses",
    "text": "Courses\n+ MIT: *Applied Data Science Program*\n+ HEC Montreal: *MATH60629A - Machine Learning I*"
  },
  {
    "objectID": "index.html#experiences",
    "href": "index.html#experiences",
    "title": "Davood Wadi",
    "section": "Experiences",
    "text": "Experiences\n\nPhD in Marketing - HEC Montreal (Best 2023 Thesis Award Nominee)\nPartner with intelChain.io as AI Scientist"
  },
  {
    "objectID": "courses.html#course-outline",
    "href": "courses.html#course-outline",
    "title": "MATH60629A - Machine Learning I (Fall 2023)",
    "section": "",
    "text": "Davood Wadi\n\nPart-time Faculty Lecturer\ndavood.wadi@hec.ca\n\nValérie Boucher\n\nAssistant to Academic Activities\nvalerie.boucher@hec.ca\n514-340-5670\nOffice: 4.632\nAvailability:\n\nMonday to Friday\n8:30 a.m. to 12 p.m. and 1 to 4:00 p.m.\n\n\nAntonietta Florio\n\nAssistant to Academic Activities\nantonietta.florio@hec.ca\n514-340-6473\nOffice: 4.632\nAvailability:\n\nFrom Monday to Friday\nFrom 8 am to 12 pm and from 1 pm to 4:30 pm\n\n\nJennifer Caron\n\nExecutive Assistant\njennifer.caron@hec.ca\n514-340-6473\nOffice: 4.632\nAvailability:\n\nFrom Monday to Friday\nFrom 8 am to 12 pm and from 1 pm to 4:30 pm\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Elements of Statistical Learning: Data Mining, Inference, and Prediction\n\nAvailable online\n\nGoodfellow, Ian . Deep learning , MIT Press ISBN: 9780262035613\n\nAvailable online\n\nRichard S. Sutton, Andrew G. Barto. A Bradford Book (2017 (in progress)). Reinforcement Learning: An Introduction Hardcover, 2nd edition ed., The MIT Press\n\nAvailable online\n\nMurphy, Kevin (2012). Machine Learning: A Probabilistic Perspective, MIT Press ISBN: 9780262018029\n\nAvailable at the library\n\nRicci, Francesco. Recommender systems handbook, Springer ISBN: 148997637X\n\nAvailable at the library\n\nParsian, Mahmoud (2015). Data algorithms: recipes for scaling up with Hadoop and Spark, O’Reilly Media ISBN: 9781491906156\n\nAvailable at the library\n\nMcKinney, Wes. Python for data analysis: data wrangling with Pandas, NumPy, and IPython, O’Reilly Media\n\nAvailable at the library\n\nBishop, Christopher (2006). Pattern Recognition and Machine Learning, Springer-Verlag New York ISBN: 9780387310732\n\nAvailable at the library\n\nLeskovec, Jurij. Mining of massive datasets, Cambridge University Press\n\nAvailable at the library\n\nGrus, Joel. Data science from scratch, O’Reilly Media\n\nAvailable at the library\n\nSandy Ryza, Uri Laserson, Sean Owen, Josh Wills (2017). Advanced analytics with Spark: patterns from learning from data at scale, 2nd edition ed., O’Reilly Media\n\nAvailable at the library\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLocation\n\nBuilding C-Ste-Cath, Room Groupe Cholette\n\nTime\n\nTuesdays, 3:30 PM - 6:30 PM EDT\n\nFinal Exam\n\nDec 14, 2023\n9:00 am - 12:00 pm EDT\nLocation to be communicated"
  },
  {
    "objectID": "courses.html#course-information",
    "href": "courses.html#course-information",
    "title": "MATH60629A - Machine Learning I (Fall 2023)",
    "section": "",
    "text": "Code Tutorials | Contact Information | Bibliographic Sources | Class Information | Evaluations | Session Materials\n\n\n\nWeek 1\n\nPython basics\n\nWeek 2\n\nModel capacity\nOverfitting\n\n\n\n\n\n\n\n\n\n\n\n\nDavood Wadi\n\nPart-time Faculty Lecturer\ndavood.wadi@hec.ca\nFor office hours:\n\nBook meeting\n\n\nValérie Boucher\n\nAssistant to Academic Activities\nvalerie.boucher@hec.ca\n514-340-5670\nOffice: 4.632\nAvailability:\n\nMonday to Friday\n8:30 a.m. to 12 p.m. and 1 to 4:00 p.m.\n\n\nAntonietta Florio\n\nAssistant to Academic Activities\nantonietta.florio@hec.ca\n514-340-6473\nOffice: 4.632\nAvailability:\n\nFrom Monday to Friday\nFrom 8 am to 12 pm and from 1 pm to 4:30 pm\n\n\nJennifer Caron\n\nExecutive Assistant\njennifer.caron@hec.ca\n514-340-6473\nOffice: 4.632\nAvailability:\n\nFrom Monday to Friday\nFrom 8 am to 12 pm and from 1 pm to 4:30 pm\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Elements of Statistical Learning: Data Mining, Inference, and Prediction\n\nAvailable online\n\nGoodfellow, Ian . Deep learning , MIT Press ISBN: 9780262035613\n\nAvailable online\n\nRichard S. Sutton, Andrew G. Barto. A Bradford Book (2017 (in progress)). Reinforcement Learning: An Introduction Hardcover, 2nd edition ed., The MIT Press\n\nAvailable online\n\nMurphy, Kevin (2012). Machine Learning: A Probabilistic Perspective, MIT Press ISBN: 9780262018029\n\nAvailable at the library\n\nRicci, Francesco. Recommender systems handbook, Springer ISBN: 148997637X\n\nAvailable at the library\n\nParsian, Mahmoud (2015). Data algorithms: recipes for scaling up with Hadoop and Spark, O’Reilly Media ISBN: 9781491906156\n\nAvailable at the library\n\nMcKinney, Wes. Python for data analysis: data wrangling with Pandas, NumPy, and IPython, O’Reilly Media\n\nAvailable at the library\n\nBishop, Christopher (2006). Pattern Recognition and Machine Learning, Springer-Verlag New York ISBN: 9780387310732\n\nAvailable at the library\n\nLeskovec, Jurij. Mining of massive datasets, Cambridge University Press\n\nAvailable at the library\n\nGrus, Joel. Data science from scratch, O’Reilly Media\n\nAvailable at the library\n\nSandy Ryza, Uri Laserson, Sean Owen, Josh Wills (2017). Advanced analytics with Spark: patterns from learning from data at scale, 2nd edition ed., O’Reilly Media\n\nAvailable at the library\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLocation\n\nBuilding C-Ste-Cath, Room Groupe Cholette\n\nTime\n\nTuesdays, 3:30 PM - 6:30 PM EDT"
  },
  {
    "objectID": "courses.html#evaluations",
    "href": "courses.html#evaluations",
    "title": "MATH60629A - Machine Learning I (Fall 2023)",
    "section": "Evaluations",
    "text": "Evaluations\n\n[Bonus] Class participation (5%)\nTo receive this 5% bonus point:\n\nPrepare for each session’s code before the class starts.\nLog in to deepnote with your Full Name.\nDuring the coding exercises in class, add your answer to the questions as a comment.\n\n\n\nHomework (20%)\n\nDue on 24 October 2023\nHomework assignments are counted for 20% of your final grade.\nThe homework should be done in jupyter notebook here or Google Colab here.\nInstructions:\n\nThe homework is due by 11:59PM EST on the due date.\nPlease upload a PDF version of your assignment on ZoneCours and insert the shareable link to your notebook in the same interface.\nHomeworks must be completed individually.\n\nDiscussion with others is okay, but you must write solutions yourself.\n\nAll code used to arrive at answers is submitted along with answers.\nNotes:\n\nPlease provide your code answers in the code block under each question and verbal answers in text boxes assigned in the notebook (where applicable).\nPlease run the notebook before the submission so that the outputs are displayed.\nPlease make sure that your results are reproducible. You may use random seeds from random and numpy packages. For scikit-learn modules, you may use the random_state argument.\n\n\n\n\n\nProject (30%)\nThe aim of this project is to allow you to learn about machine learning by trying to solve a task with it.\nFirst, select a question that can be answered using machine learning. I expect that your question will be about a model/algorithm or about an application. Then design a study that will try to answer your question. Your study must have an element of novelty. For example the novelty could be an extension or a variation of an existing algorithm or results of an existing method on a new dataset.\nYour study should involve reading and understanding some background material. Your study must involve running some experiments. You are free to use (or not) any of the tools or models we have seen in class.\nStudy plan: (1 upload per group) Please submit a one-page summary of your proposed research question and study to ZoneCours. I will meet with each group to discuss study plans during the lecture on Week 9. I will send you a schedule the day before. We will probably only have about 15 minutes so please make sure that your study plan is clear and precise. You may also include questions that you would like us to discuss at the end of the document.\nThe group report: (1 upload per group) Your report must contain a description of the question you are trying to answer, a clear description of the model/algorithm you are studying, a survey of related work which proper references, an empirical section that reports your results, and a conclusion that summarizes your findings and (if pertinent) highlights possible future directions of investigation. Your report should be no longer than 10 pages in length (plus references) for pairs or 13 pages (plus references) for teams of three.\nThe individual report: (1 upload per student) You will also submit a brief individual report (at most one page), which will: (1) Describe the parts of the project you worked on (which machine learning methods you applied, which preprocessing steps you performed on the data, which parts of the term paper you wrote, who you worked with on what parts, etc.) and what parts of the project your teammates worked on. (2) What you learned from the project. The purpose of the individual report is to facilitate fair grading and to allow the instructor to understand well what you learned from the project.\nProject Report (30%)\n\nClarity/Relevance of problem statement and description of approach: 10%\nDiscussion of relationship to previous work and references: 4%\nDesign and execution of experiments: 10% Figures/Tables/Writing: easily readable, properly labeled, * informative: 5%\nIndiviual report: 1%\n\n\nTimeline\n\nTeam Registration, due: October 1. Fill this form.\nStudy plan, due: October 28 (by the end of the day EDT).\nHanding in: Through ZoneCours\nProject meeting, October 31\nProject Presentation, due: December 1. Upload the PDF of your poster/slides to ZoneCours.\nIn-class Presentation, on December 5.\nFinal individual report, due: December 15, 2023 (by the end of the day EDT).\n\nHanding in: Through ZoneCours (per each team member).\n\n\n\n\n\nProject Presentation (10%)\nMake a poster that describes your project. You can think of a poster as supporting material for your oral presentation (in that way it is similar to slides). It could also follow a similar structure: begin by motivating your work, then (quickly) highlight related work, talk in depth about your solution, then go into results (pictures and tables are good tools for that), finally conclude and perhaps mention one or two ideas for future work.\n\nProject Presentation (10%)\n\nClarity of presentation: 3%\nSlide or Poster quality: 2%\nCorrectness: 2%\nAnswers to questions: 3%\n\n\n\n\nFinal Exam (30%)\n\nDec 14, 2023\n9:00 am - 12:00 pm EDT\nLocation to be communicated\n\nPast exam - Fall 2018\n\n\nCapsule Quizzes (10%)\n\nIn-class quizzes of the capsules\nCapsule quizzes are counted for 10% of your final grade.\n\nQuiz 0, TBA.\nQuiz 1, TBA.\nQuiz 2, TBA.\nQuiz 3, TBA.\nQuiz 4, TBA.\nQuiz 5, TBA.\nQuiz 6, TBA."
  },
  {
    "objectID": "docs/MATH60629A_Homework.html",
    "href": "docs/MATH60629A_Homework.html",
    "title": "Instructions:",
    "section": "",
    "text": "Due date: October 24, 2023\n# enter you full name and HEC ID\nfull_name = \"\"\nHEC_ID = \"\""
  },
  {
    "objectID": "docs/MATH60629A_Homework.html#svm-for-classfication",
    "href": "docs/MATH60629A_Homework.html#svm-for-classfication",
    "title": "Instructions:",
    "section": "SVM for classfication",
    "text": "SVM for classfication\n\n(1pt) Train a linear SVM on the training set for each one of these C hyperparameter values: {0:001; 0:01; 0:1; 1; 10}. Find the best hyperparameter on the validation set.\n\n\n[Your code here]\n\n\n(1pt) Using the best hyperparameter C, evaluate the accuracy, precision, recall, and F1-score on the test set.\n\n\n[Your code here]\n\n\n(0.5pt) Plot the confusion matrix on the test set and explain the reason for your false negatives/positives.\n\n\n[Your code here]\n\nObservations\n[_____]"
  },
  {
    "objectID": "MATH60629A_Homework.html",
    "href": "MATH60629A_Homework.html",
    "title": "Instructions:",
    "section": "",
    "text": "Due date: October 24, 2023\n# enter you full name and HEC ID\nfull_name = \"\"\nHEC_ID = \"\""
  },
  {
    "objectID": "MATH60629A_Homework.html#svm-for-classfication",
    "href": "MATH60629A_Homework.html#svm-for-classfication",
    "title": "Instructions:",
    "section": "SVM for classfication",
    "text": "SVM for classfication\n\n(1pt) Train a linear SVM on the training set for each one of these C hyperparameter values: {0:001; 0:01; 0:1; 1; 10}. Find the best hyperparameter on the validation set.\n\n\n[Your code here]\n\n\n(1pt) Using the best hyperparameter C, evaluate the accuracy, precision, recall, and F1-score on the test set.\n\n\n[Your code here]\n\n\n(0.5pt) Plot the confusion matrix on the test set and explain the reason for your false negatives/positives.\n\n\n[Your code here]\n\nObservations\n[_____]"
  },
  {
    "objectID": "sessions.html",
    "href": "sessions.html",
    "title": "MATH60629A - Machine Learning I (Fall 2023)",
    "section": "",
    "text": "Week 1 - Class introduction and math review [slides]\n\n\n\n\n\n\nCode tutorial\nRequired reading: Prologue to The Master Algorithm\nSuggested reading:\n\nChapter 1 of ESL\nTo explain or to predict\n\nMath review (if needed): have a look at the resources page.\n\n\n\n\n\n\n\n\n\n\nWeek 2 - Machine learning fundamentals\n\n\n\n\n\n\nRequired readings: Chapter 5 of Deep Learning (the book).\n\nYou can skim 5.4 (except 5.4.4) to 5.10.\n\nCapsules: [slides]\n\nLearning Problem [14:40]\nTypes of Experiences [13:15]\nA first Supervised Model [8:03]\nModel Evaluation [15:26]\nRegularization [4:09]\nModel Validation [3:08]\nBias / Variance tradeoff [11:50]\n\nIn-class material:\n\nSummary\nExercises (colab)\nIf you do not want to use colab, here are the two files you need to download: 1a) Fundamentals_questions.ipynb AND 2) utilities.py\n\n\n\n\n\n\n\n\n\n\n\nWeek 3 - Supervised learning algorithms\n\n\n\n\n\n\nReferences:\nSections 4.1-4.3, 4.5 of The Elements of Statistical Learning (available online),\nSections 3.5 and 4.2 of Machine Learning (K. Murphy)\nCapsules: [slides]\n\nNearest Neighbor [19:05]\nLinear Classification [15:26]\nIntroduction to Probabilistic Models (for Classification) [11:55]\nThe Naive Bayes Model [24:28]\nNaive Bayes Example [9:26]\n\nIn-class material:\n\nSummary\nExercises (colab)\nIf you do not want to use colab, here are the two files you need to download: 1a) Supervised_questions.ipynb AND 2) utils.py\n\n\n\n\n\n\n\n\n\n\n\nWeek 4 - Python for scientific computations and machine learning [Practical Session]\n\n\n\n\n\n\nThe tutorial that you will follow is here (on colab).\nI encourage you to start the tutorial ahead of time and to finish it during our 180 minutes together.\n\n\n\n\n\n\n\n\n\n\nWeek 5 - Neural networks and deep learning\n\n\n\n\n\n\nRequired readings:\nSections 6.1–6.3 and 6.5 (stop at 6.5.4) of Deep Learning (the book).\nOther reference:\nChapter 11 of the Elements of Statistical Learning (available online).\nCapsules: [slides]\n\nFrom linear classification to neural networks [19:28]\nTraining neural networks [20:14]\nLearning representations [13:40]\nNeural networks hyperparameters [25:20]\nNeural networks takeaways [7:00]\n\nIn-class exercises:\n\nSummary\nExercises (colab)\n\n\n\n\n\n\n\n\n\n\n\nWeek 6 - Recurrent Neural networks and Convolutional neural networks [Optional: Transformers]\n\n\n\n\n\n\nRequired readings:\nSections 10, 10.1, 10.2 (skim 10.2.2, skip 10.2.3), and 10.7. Sections 9, 9.1, 9.2, 9.3 (9.11 for fun).\nBoth from Deep Learning (the book).\nCapsules: [slides]\n\nModelling Sequential Data [8:42]\nPractical Overview of RNNs [29:32]\nRNNs for language modelling [15:13]\nOverview of CNNs [13:30]\nConvolutions and Pooling [26:00]\nConclusions and Practical remarks [9:17]\n\nIn-class material:\n\nSummary\nExercises RNNs (colab)\nExercises CNNs (colab)\n\n\nAttention and Transformers [Optional]\n\nCapsules: [Slides]\n\nTransformers: Application [5:57]\nHistory of Transformers and Attention Layers [6:01]\nWord and Position Encoding [11:46]\nSelf-Attention Layers [9:07]\nMulti Head Attention and Visual Transformers [4:59]\n\n\n\n\n\n\n\n\n\n\n\nWeek 7 - Unsupervised learning\n\n\n\n\n\n\nRequired reading:\nSection 14.3 (skip 14.3.5 and 14.3.12) of the Elements of Statistical Learning.\nCapsules: [slides]\n\nIntroduction to unsupervised learning [8:17]\nK-means clustering [41:58] (there’s a natural break at 22:28)\nGMMs for clustering [17:52]\nBeyond Clustering [14:42]\n\nIn-class material:\n\nSummary\nExercises (colab)\n\n\n\n\n\n\n\n\n\n\n\nWeek 8 - Reading week (no class)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 9 - Project team meetings\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 10 - Parallel computational paradigms for large-scale data processing\n\n\n\n\n\n\nCapsules: [Slides]\n\nIntro. to Distributed Computing for ML [19:35]\nMapReduce [17:41]\nSpark [17:37]\n\nSummary\n\n\n\n\n\n\n\n\n\n\nWeek 11 - Recommender systems\n\n\n\n\n\n\nRequired preparation for the case:\nCase Presentation and class execution (answer to Question 1 must be submitted by the 13 at the latest)\nClass slides\n\n\n\n\n\n\n\n\n\n\nWeek 12 - Sequential decision making I\n\n\n\n\n\n\nCapsules: [slides]\n\nMotivating RL [8:22]\nPlanning with MDPs [12:16]\nMDP objective [14:16]\nAlgorithms for solving MDPs [17:51]\n\nNote: In this capsule, there is a mistake in the second equation of the policy iteration algorithm (the transition should be given a and not π(s)), the slides have been corrected (see slides 47 and 48)\nOptional: Demo of the policy iteration algorithm (from Andrej Karpathy)\nIn-class material:\n\nSummary\nExercises (colab)\n\n\n\n\n\n\n\n\n\n\n\nWeek 13 - Sequential decision making II\n\n\n\n\n\n\nCapsules: [slides]\n\nIntroduction to RL [13:31]\nA first RL algorithm [17:13]\nRL Algorithms for Control [21:10]\n\nRequired reading: Sections 1 through 4 from this Survey\nOther reading: Chapters 1,3,4, and 6 from Reinforcement Learning: An Introduction\nOptional: Demo of the TD algorithm (from Andrej Karpathy)\nIn-class material:\n\nSummary\nExercises (colab)\n\n\n\n\n\n\n\n\n\n\n\nWeek 14 - Class project presentations"
  },
  {
    "objectID": "sessions.html#session-materials",
    "href": "sessions.html#session-materials",
    "title": "MATH60629A - Machine Learning I (Fall 2023)",
    "section": "",
    "text": "Week 1 - Class introduction and math review [slides]\n\n\n\n\n\n\nCode tutorial\nRequired reading: Prologue to The Master Algorithm\nSuggested reading:\n\nChapter 1 of ESL\nTo explain or to predict\n\nMath review (if needed): have a look at the resources page.\n\n\n\n\n\n\n\n\n\n\nWeek 2 - Machine learning fundamentals\n\n\n\n\n\n\nRequired readings: Chapter 5 of Deep Learning (the book).\n\nYou can skim 5.4 (except 5.4.4) to 5.10.\n\nCapsules: [slides]\n\nLearning Problem [14:40]\nTypes of Experiences [13:15]\nA first Supervised Model [8:03]\nModel Evaluation [15:26]\nRegularization [4:09]\nModel Validation [3:08]\nBias / Variance tradeoff [11:50]\n\nIn-class material:\n\nSummary\nExercises (colab)\nIf you do not want to use colab, here are the two files you need to download: 1a) Fundamentals_questions.ipynb AND 2) utilities.py\n\n\n\n\n\n\n\n\n\n\n\nWeek 3 - Supervised learning algorithms\n\n\n\n\n\n\nReferences:\nSections 4.1-4.3, 4.5 of The Elements of Statistical Learning (available online),\nSections 3.5 and 4.2 of Machine Learning (K. Murphy)\nCapsules: [slides]\n\nNearest Neighbor [19:05]\nLinear Classification [15:26]\nIntroduction to Probabilistic Models (for Classification) [11:55]\nThe Naive Bayes Model [24:28]\nNaive Bayes Example [9:26]\n\nIn-class material:\n\nSummary\nExercises (colab)\nIf you do not want to use colab, here are the two files you need to download: 1a) Supervised_questions.ipynb AND 2) utils.py\n\n\n\n\n\n\n\n\n\n\n\nWeek 4 - Python for scientific computations and machine learning [Practical Session]\n\n\n\n\n\n\nThe tutorial that you will follow is here (on colab).\nI encourage you to start the tutorial ahead of time and to finish it during our 180 minutes together.\n\n\n\n\n\n\n\n\n\n\nWeek 5 - Neural networks and deep learning\n\n\n\n\n\n\nRequired readings:\nSections 6.1–6.3 and 6.5 (stop at 6.5.4) of Deep Learning (the book).\nOther reference:\nChapter 11 of the Elements of Statistical Learning (available online).\nCapsules: [slides]\n\nFrom linear classification to neural networks [19:28]\nTraining neural networks [20:14]\nLearning representations [13:40]\nNeural networks hyperparameters [25:20]\nNeural networks takeaways [7:00]\n\nIn-class exercises:\n\nSummary\nExercises (colab)\n\n\n\n\n\n\n\n\n\n\n\nWeek 6 - Recurrent Neural networks and Convolutional neural networks [Optional: Transformers]\n\n\n\n\n\n\nRequired readings:\nSections 10, 10.1, 10.2 (skim 10.2.2, skip 10.2.3), and 10.7. Sections 9, 9.1, 9.2, 9.3 (9.11 for fun).\nBoth from Deep Learning (the book).\nCapsules: [slides]\n\nModelling Sequential Data [8:42]\nPractical Overview of RNNs [29:32]\nRNNs for language modelling [15:13]\nOverview of CNNs [13:30]\nConvolutions and Pooling [26:00]\nConclusions and Practical remarks [9:17]\n\nIn-class material:\n\nSummary\nExercises RNNs (colab)\nExercises CNNs (colab)\n\n\nAttention and Transformers [Optional]\n\nCapsules: [Slides]\n\nTransformers: Application [5:57]\nHistory of Transformers and Attention Layers [6:01]\nWord and Position Encoding [11:46]\nSelf-Attention Layers [9:07]\nMulti Head Attention and Visual Transformers [4:59]\n\n\n\n\n\n\n\n\n\n\n\nWeek 7 - Unsupervised learning\n\n\n\n\n\n\nRequired reading:\nSection 14.3 (skip 14.3.5 and 14.3.12) of the Elements of Statistical Learning.\nCapsules: [slides]\n\nIntroduction to unsupervised learning [8:17]\nK-means clustering [41:58] (there’s a natural break at 22:28)\nGMMs for clustering [17:52]\nBeyond Clustering [14:42]\n\nIn-class material:\n\nSummary\nExercises (colab)\n\n\n\n\n\n\n\n\n\n\n\nWeek 8 - Reading week (no class)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 9 - Project team meetings\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 10 - Parallel computational paradigms for large-scale data processing\n\n\n\n\n\n\nCapsules: [Slides]\n\nIntro. to Distributed Computing for ML [19:35]\nMapReduce [17:41]\nSpark [17:37]\n\nSummary\n\n\n\n\n\n\n\n\n\n\nWeek 11 - Recommender systems\n\n\n\n\n\n\nRequired preparation for the case:\nCase Presentation and class execution (answer to Question 1 must be submitted by the 13 at the latest)\nClass slides\n\n\n\n\n\n\n\n\n\n\nWeek 12 - Sequential decision making I\n\n\n\n\n\n\nCapsules: [slides]\n\nMotivating RL [8:22]\nPlanning with MDPs [12:16]\nMDP objective [14:16]\nAlgorithms for solving MDPs [17:51]\n\nNote: In this capsule, there is a mistake in the second equation of the policy iteration algorithm (the transition should be given a and not π(s)), the slides have been corrected (see slides 47 and 48)\nOptional: Demo of the policy iteration algorithm (from Andrej Karpathy)\nIn-class material:\n\nSummary\nExercises (colab)\n\n\n\n\n\n\n\n\n\n\n\nWeek 13 - Sequential decision making II\n\n\n\n\n\n\nCapsules: [slides]\n\nIntroduction to RL [13:31]\nA first RL algorithm [17:13]\nRL Algorithms for Control [21:10]\n\nRequired reading: Sections 1 through 4 from this Survey\nOther reading: Chapters 1,3,4, and 6 from Reinforcement Learning: An Introduction\nOptional: Demo of the TD algorithm (from Andrej Karpathy)\nIn-class material:\n\nSummary\nExercises (colab)\n\n\n\n\n\n\n\n\n\n\n\nWeek 14 - Class project presentations"
  },
  {
    "objectID": "courses.html#in-class-tools",
    "href": "courses.html#in-class-tools",
    "title": "MATH60629A - Machine Learning I (Fall 2023)",
    "section": "In-class Tools",
    "text": "In-class Tools\n\nCups pacing webapp"
  },
  {
    "objectID": "code/Session1.html",
    "href": "code/Session1.html",
    "title": "Python Basics",
    "section": "",
    "text": "To start let’s load NumPy, a package for scientific computing with Python. We usually load it as the np shorthand.\n\nimport numpy as np\n\nLet’s initialize two arrays\n\na = np.random.randn(1,5)\nb = np.random.randn(1,5)"
  },
  {
    "objectID": "code/Session1.html#loading-necessary-packages",
    "href": "code/Session1.html#loading-necessary-packages",
    "title": "Python Basics",
    "section": "",
    "text": "To start let’s load NumPy, a package for scientific computing with Python. We usually load it as the np shorthand.\n\nimport numpy as np\n\nLet’s initialize two arrays\n\na = np.random.randn(1,5)\nb = np.random.randn(1,5)"
  },
  {
    "objectID": "code/Session1.html#dot-product",
    "href": "code/Session1.html#dot-product",
    "title": "Python Basics",
    "section": "Dot product",
    "text": "Dot product\nTo perform a dot product of two arrays, the shape of the arrays should match. Let’s get the shape of our arrays.\n\na.shape, b.shape\n\n((1, 5), (1, 5))\n\n\nboth arrays have a shape of \\((1, 5)\\).\nIn general, the shape of the two arrays should be \\((n, k) (k, m)\\), where \\(k\\) is the common dimension of the two arrays.\nFor our example, we can transpose the array b to make the shapes match. The NumPy command for transposition of arrays is .T.\n\na.shape, b.T.shape\n\n((1, 5), (5, 1))\n\n\nNow that the two arrays have the matching shapes, we can calculate their dot product using the @ operator.\n\na @ b.T\n\narray([[0.56077435]])\n\n\nThe result of the dot product is an array of shape \\((1,1)\\), or a scalar. In general, the result of a dot product has a shape of \\((n, m)\\)"
  },
  {
    "objectID": "code/Session1.html#best-fit-line",
    "href": "code/Session1.html#best-fit-line",
    "title": "Python Basics",
    "section": "Best fit line",
    "text": "Best fit line\nLet us now simulate a some data and find the best fit line, a line that minimizes the average distance of all data points to the line.\nHere our X is a vector of shape \\((100, 1)\\) samples from a standard normal distribution. Here we have \\(100\\) points with \\(1\\) feature for each point.\nThe y is 10 times x, with the shape \\((100, 1)\\).\n\\[y = X \\cdot coeff\\]\n\nX = np.random.randn(100, 1)\ncoeff = np.ones((1, 1)) * 10\ny = X @ coeff\ny.shape\n\n(100, 1)"
  },
  {
    "objectID": "code/Session1.html#fitting-the-data-using-sklearn",
    "href": "code/Session1.html#fitting-the-data-using-sklearn",
    "title": "Python Basics",
    "section": "Fitting the data using sklearn",
    "text": "Fitting the data using sklearn\nIn the next session, we will formulate a closed-form solution for finding the parameters of linear regression.\nFor now, let’s use the scikit-learn package to find the best line.\nWe’ll import the LinearRegression class from the linear_model submodule of sklearn. Each submodule of sklearn contains classes for that particular topic.\n\nfrom sklearn.linear_model import LinearRegression\n\nNow, let’s create an instance of the LinearRegression model and fit it to the data.\n\nmodel = LinearRegression()\n\n\nmodel.fit(X,y)\n\nLinearRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LinearRegressionLinearRegression()\n\n\nMost sklearn classes involve two steps: 1. Instantiating the class. This is where you provide the necessary hyper-parameters. - model = LinearRegression() 2. Fitting the data. - model.fit(X,y)\nNext, we can retrieve the coefficients of the fitted model by accessing the .coeff_ attribute of the model object.\n\na = model.coef_\na\n\narray([[10.]])\n\n\nIn our case, the coefficient is an array of shape \\((1,1)\\). This is in line with the shape of our X (\\(n,1\\)) and y (\\(n, 1\\)).\nWe can also access the intercept of the model using the .intercept_ attribute. Since we didn’t add an intercept in our data simulation, the value of the intercept should be \\(0\\).\nNote. In numerical computations, very small numbers (e.g. \\(2 \\times 10^{-16}\\)) are considered to be \\(0\\).\n\nb = model.intercept_\nb\n\narray([2.22044605e-16])"
  },
  {
    "objectID": "code/Session1.html#plotting-the-line-on-the-data",
    "href": "code/Session1.html#plotting-the-line-on-the-data",
    "title": "Python Basics",
    "section": "Plotting the line on the data",
    "text": "Plotting the line on the data\nWe can now plot the line and the data to see the fit.\nFirst, we get the predictions from the model using its fitted parameters a and b.\n\ny_pred = X @ a + b\n\nWe’ll use seaborn and Matplotlib to create two separate plots on the same axis, ax.\n\nax = sns.scatterplot(x=X[:,0], y=y[:,0], label=\"Actual y\")\nax = sns.lineplot(x=X[:,0], y=y_pred[:,0], ax=ax, color='red', label=\"Predicted y\")\nax.legend()\n\n&lt;matplotlib.legend.Legend at 0x120000280&gt;"
  },
  {
    "objectID": "code/Model.html",
    "href": "code/Model.html",
    "title": "Model capacity",
    "section": "",
    "text": "Model capacity refers to the ability of a machine learning model to capture and represent complex relationships between the input variables (features) and the target variable (labels). It determines the complexity and flexibility of the model in fitting the training data.\nIn other words, model capacity represents the amount of information or patterns that a model can learn from the data. A model with a high capacity can learn intricate relationships in the training data, which may result in overfitting. On the other hand, a model with low capacity may not be able to capture the underlying patterns in the data, leading to underfitting.\nThe capacity of a model can be controlled by adjusting its architectural complexity. For example, in neural networks, increasing the number of hidden layers and hidden units increases the capacity of the model.\nMathematically, we can define model capacity as the number of parameters that the model has to learn. For example, in linear regression, the model capacity is determined by the number of coefficients (slope and intercept) that the model needs to estimate. In neural networks, the model capacity is determined by the number of weights and biases associated with each neuron.\nNow, let’s understand the concept of model capacity using a simple example with polynomial regression. Polynomial regression is a form of linear regression where the relationship between the input feature (x) and the target variable (y) is modeled as an nth-degree polynomial.\nFirst, let’s generate some synthetic data that follows a quadratic relationship between x and y:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Generate synthetic data\nnp.random.seed(42)\nx = np.linspace(-5, 5, 100)\ny = 2 * x ** 2 + np.random.normal(0, 4, 100)\n\n# Plot the data\nplt.scatter(x, y)\nplt.xlabel('x')\nplt.ylabel('y')\nplt.title('Quadratic Relationship')\nplt.show()\n\n\n\n\nBy visualizing the data, we can observe that the relationship between x and y follows a quadratic curve. Now, let’s try fitting this data using different polynomial regression models with different degrees of complexity.\n\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.pipeline import make_pipeline\n\n# Fit linear regression model\nlinear_model = make_pipeline(PolynomialFeatures(degree=1), LinearRegression())\nlinear_model.fit(x.reshape(-1, 1), y)\n\n# Fit quadratic regression model\nquadratic_model = make_pipeline(PolynomialFeatures(degree=2), LinearRegression())\nquadratic_model.fit(x.reshape(-1, 1), y)\n\n# Fit cubic regression model\ncubic_model = make_pipeline(PolynomialFeatures(degree=3), LinearRegression())\ncubic_model.fit(x.reshape(-1, 1), y)\n\n# Predict on new data points\nx_test = np.linspace(-5, 5, 100)\ny_linear = linear_model.predict(x_test.reshape(-1, 1))\ny_quadratic = quadratic_model.predict(x_test.reshape(-1, 1))\ny_cubic = cubic_model.predict(x_test.reshape(-1, 1))\n\n# Plot the regression curves\nplt.scatter(x, y, label='Data')\nplt.plot(x_test, y_linear, label='Linear')\nplt.plot(x_test, y_quadratic, label='Quadratic')\nplt.plot(x_test, y_cubic, label='Cubic')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.title('Polynomial Regression')\nplt.legend()\nplt.show()\n\n\n\n\nIn the above code, we fit three polynomial regression models: linear, quadratic, and cubic regression. The degree of the polynomial is indicated by the degree parameter in the PolynomialFeatures class. We can observe that as we increase the complexity (degree) of the polynomial, the models can better capture the underlying quadratic relationship.\nHowever, it’s important to note that high-capacity models can also be prone to overfitting, especially when the amount of training data is limited. Therefore, it’s crucial to balance the model’s capacity with the complexity of the problem at hand and the size of the training dataset.\nTo summarize, model capacity refers to the amount of information or patterns a machine learning model can learn from the data. It is determined by the number of parameters that the model needs to estimate. Increasing the model’s capacity can improve its ability to represent complex relationships in the data, but it can also increase the risk of overfitting."
  },
  {
    "objectID": "code/overfi.html",
    "href": "code/overfi.html",
    "title": "Overfitting",
    "section": "",
    "text": "Overfitting occurs when a machine learning model performs very well on the training data, but fails to generalize well on unseen data. It happens when the model captures noise and random fluctuations in the training data instead of the underlying pattern or relationship.\nOne way to understand overfitting is to consider fitting a polynomial to data points. The degree of the polynomial determines its complexity. A higher degree polynomial can fit the training data more closely, but it may also capture random noise, resulting in poor performance on new data.\nTo demonstrate overfitting using polynomials, we will generate a dataset with some noise and fit polynomials of different degrees to it. We will then visualize the models to see how they fit the data.\nLet’s start by importing the necessary libraries and generating the dataset. We will use the numpy library for array operations and random number generation, and the matplotlib library for data visualization.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Generate the dataset\nnp.random.seed(0)\nX = np.linspace(-1, 1, 20)\ny = 2 * X + np.random.normal(0, 0.5, 20)\n\nIn the above code, we first import the required libraries: numpy and matplotlib.pyplot. We then set a random seed to ensure reproducibility.\nNext, we create an array X with 20 equally spaced points between -1 and 1 using the linspace function. We add some noise to the array y using the numpy.random.normal function. Here, we use a linear relationship with some Gaussian noise to generate our dataset.\nNow, we will plot the generated dataset to visualize it.\n\nplt.scatter(X, y)\nplt.xlabel('X')\nplt.ylabel('y')\nplt.title('Dataset')\nplt.show()\n\n\n\n\nThe code above uses the scatter function from matplotlib.pyplot to create a scatter plot of the dataset. It also adds labels to the x and y axes and sets a title for the plot. Finally, the show function is called to display the plot.\nNow, let’s fit polynomials of different degrees to the dataset and see how they fit the data.\n\n# Polynomial fitting and visualization\ndegrees = [1, 3, 9, 12]\n\nplt.scatter(X, y)\n\nfor degree in degrees:\n    # Fit polynomial of given degree\n    coeffs = np.polyfit(X, y, degree)\n    poly = np.poly1d(coeffs)\n    \n    # Generate x values for plotting\n    x_plot = np.linspace(-1, 1, 100)\n    \n    # Compute predicted y values\n    y_plot = poly(x_plot)\n    \n    # Plot the polynomial\n    plt.plot(x_plot, y_plot, label=f'Degree {degree}')\n\nplt.xlabel('X')\nplt.ylabel('y')\nplt.title('Fitting Polynomials')\nplt.legend()\nplt.show()\n\n\n\n\nIn the above code, we define a list degrees with the degrees of the polynomials that we want to fit to the dataset. We then iterate over each degree and perform the following steps:\n\nFit a polynomial of the given degree to the dataset using the polyfit function from numpy.\nCreate a polynomial object using the computed coefficients using the poly1d function from numpy.\nGenerate a set of x values for plotting using the linspace function from numpy.\nCompute the predicted y values for the generated x values using the polynomial.\nPlot the polynomial curve using the plot function from matplotlib.pyplot with a label indicating the degree of the polynomial.\n\nFinally, we add labels and a title to the plot, and display a legend to distinguish the different polynomial curves.\nWhen you run the code, you will see a plot showing the dataset points as scatter points, and different polynomial curves fitted to the data. From this visualization, you can observe the effect of overfitting as the degree of the polynomial increases. Higher degree polynomials tend to fit the training data more closely, but they also capture random noise and fluctuations, resulting in poor generalization to new data."
  }
]