{
  "hash": "8313a9d7745ab763fa8bf7c7876f70b5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"\"\nformat:\n  html:\n    code-fold: false\njupyter: python3\nexecute: \n  cache: true\n---\n\n\n\n\n\nIn PyTorch, the `torch.utils.data.Dataset` class is used to represent a dataset. It provides an interface to access individual samples in the dataset, which can be used to train and evaluate machine learning models. This class is an abstract class, so we need to create a custom class that inherits from it and implements two methods: `__len__` and `__getitem__`.\n\nTo create a custom randomly generated dataset, we need to define a class that generates random samples and labels. Let's assume that we want to generate random 2D points along with their corresponding labels. The labels can be either 0 or 1, indicating two different classes.\n\nHere's an example implementation of the custom dataset class:\n\n::: {#c0689874 .cell execution_count=1}\n``` {.python .cell-code}\nimport torch\nfrom torch.utils.data import Dataset\n\nclass RandomDataset(Dataset):\n    def __init__(self, num_samples, num_features):\n        self.num_samples = num_samples\n        self.num_features = num_features\n        self.data = torch.randn(num_samples, num_features)\n        # Randomly assign labels of 0 or 1\n        self.targets = torch.randint(0, 2, (num_samples,))\n    \n    def __len__(self):\n        return self.num_samples\n    \n    def __getitem__(self, index):\n        sample = self.data[index]\n        label = self.targets[index]\n        return sample, label\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nA module that was compiled using NumPy 1.x cannot be run in\nNumPy 2.0.1 as it may crash. To support both 1.x and 2.x\nversions of NumPy, modules must be compiled with NumPy 2.0.\nSome module may need to rebuild instead e.g. with 'pybind11>=2.12'.\n\nIf you are a user of the module, the easiest solution will be to\ndowngrade to 'numpy<2' or try to upgrade the affected module.\nWe expect that some modules will need time to support NumPy 2.\n\nTraceback (most recent call last):  File \"/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/runpy.py\", line 196, in _run_module_as_main\n    return _run_code(code, main_globals, None,\n  File \"/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/runpy.py\", line 86, in _run_code\n    exec(code, run_globals)\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/ipykernel_launcher.py\", line 18, in <module>\n    app.launch_new_instance()\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/traitlets/config/application.py\", line 1075, in launch_instance\n    app.start()\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/ipykernel/kernelapp.py\", line 739, in start\n    self.io_loop.start()\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/tornado/platform/asyncio.py\", line 205, in start\n    self.asyncio_loop.run_forever()\n  File \"/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/asyncio/base_events.py\", line 603, in run_forever\n    self._run_once()\n  File \"/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/asyncio/base_events.py\", line 1909, in _run_once\n    handle._run()\n  File \"/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/asyncio/events.py\", line 80, in _run\n    self._context.run(self._callback, *self._args)\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/ipykernel/kernelbase.py\", line 545, in dispatch_queue\n    await self.process_one()\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/ipykernel/kernelbase.py\", line 534, in process_one\n    await dispatch(*args)\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/ipykernel/kernelbase.py\", line 437, in dispatch_shell\n    await result\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/ipykernel/ipkernel.py\", line 362, in execute_request\n    await super().execute_request(stream, ident, parent)\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/ipykernel/kernelbase.py\", line 778, in execute_request\n    reply_content = await reply_content\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/ipykernel/ipkernel.py\", line 449, in do_execute\n    res = shell.run_cell(\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/ipykernel/zmqshell.py\", line 549, in run_cell\n    return super().run_cell(*args, **kwargs)\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/IPython/core/interactiveshell.py\", line 3075, in run_cell\n    result = self._run_cell(\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/IPython/core/interactiveshell.py\", line 3130, in _run_cell\n    result = runner(coro)\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/IPython/core/async_helpers.py\", line 128, in _pseudo_sync_runner\n    coro.send(None)\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/IPython/core/interactiveshell.py\", line 3334, in run_cell_async\n    has_raised = await self.run_ast_nodes(code_ast.body, cell_name,\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/IPython/core/interactiveshell.py\", line 3517, in run_ast_nodes\n    if await self.run_code(code, result, async_=asy):\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/IPython/core/interactiveshell.py\", line 3577, in run_code\n    exec(code_obj, self.user_global_ns, self.user_ns)\n  File \"/var/folders/jv/ppbxly7j7vzgcr8sdv78s2hr0000gn/T/ipykernel_50998/4028413707.py\", line 1, in <module>\n    import torch\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/torch/__init__.py\", line 1477, in <module>\n    from .functional import *  # noqa: F403\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/torch/functional.py\", line 9, in <module>\n    import torch.nn.functional as F\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/torch/nn/__init__.py\", line 1, in <module>\n    from .modules import *  # noqa: F403\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/torch/nn/modules/__init__.py\", line 35, in <module>\n    from .transformer import TransformerEncoder, TransformerDecoder, \\\n  File \"/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/torch/nn/modules/transformer.py\", line 20, in <module>\n    device: torch.device = torch.device(torch._C._get_default_device()),  # torch.device('cpu'),\n/Users/davoodwadi/pyth/venv/lib/python3.10/site-packages/torch/nn/modules/transformer.py:20: UserWarning:\n\nFailed to initialize NumPy: _ARRAY_API not found (Triggered internally at /Users/runner/work/pytorch/pytorch/pytorch/torch/csrc/utils/tensor_numpy.cpp:84.)\n\n```\n:::\n:::\n\n\nLet's break down the code step by step:\n\n1. Import the necessary modules: `torch` and `torch.utils.data.Dataset`.\n\n2. Define a custom class called `RandomDataset` that inherits from `Dataset`.\n\n3. In the class constructor (`__init__` method), we pass the number of samples (`num_samples`) and the number of features (`num_features`) as parameters.\n\n4. Inside the constructor, we generate random data using `torch.randn` with dimensions (`num_samples`, `num_features`). This will create a tensor of random floating-point values.\n\n5. We also generate random labels using `torch.randint` with values between 0 and 1 (exclusive), and shape (`num_samples`,). This will create a tensor with integer labels.\n\n6. Implement the `__len__` method, which returns the number of samples in the dataset (`num_samples`).\n\n7. Implement the `__getitem__` method, which takes an index as input and returns the corresponding sample and label. This method is used to access individual samples in the dataset. Inside this method, we use the index to retrieve the sample and label from the data and targets tensors, respectively.\n\nNow, we can create an instance of the `RandomDataset` class and use it as a regular dataset in PyTorch.\n\n::: {#40f243d4 .cell execution_count=2}\n``` {.python .cell-code}\n# Instantiate the custom dataset\ndataset = RandomDataset(num_samples=1000, num_features=2)\n\n# Access an individual sample and its label\nsample, label = dataset[0]\nprint(\"Sample:\", sample)\nprint(\"Label:\", label)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSample: tensor([-0.7020,  0.4551])\nLabel: tensor(0)\n```\n:::\n:::\n\n\nThis will output the first sample and its corresponding label from the dataset. You can access any sample by using the index in the same way.\n\nBy defining a custom dataset class, we can generate random datasets with specific characteristics and use them for training and evaluating machine learning models in PyTorch.\n\n",
    "supporting": [
      "datasets_pytorch_files"
    ],
    "filters": [],
    "includes": {}
  }
}